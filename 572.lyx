#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass paper
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family sfdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a5paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1cm
\topmargin 1.2cm
\rightmargin 1cm
\bottommargin 1.2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle empty
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
CO572 Advanced Databases
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Database management systems
\end_layout

\begin_layout Paragraph
Requirements
\end_layout

\begin_layout Standard
Should provide:
\end_layout

\begin_layout Itemize

\series bold
Storage:
\series default
 single, reliable repository of data.
\end_layout

\begin_layout Itemize

\series bold
Transactions:
\series default
 should be atomic, consistent, isolated, durable.
\end_layout

\begin_layout Itemize

\series bold
Data analysis.
\end_layout

\begin_layout Itemize

\series bold
Programming model.
\end_layout

\begin_layout Standard
In a way that is:
\end_layout

\begin_layout Itemize

\series bold
Efficient:
\series default
 not slower than hand-written applications.
\end_layout

\begin_layout Itemize

\series bold
Resilient:
\series default
 should recover from problems.
\end_layout

\begin_layout Itemize

\series bold
Robust:
\series default
 predictable performance.
\end_layout

\begin_layout Itemize

\series bold
Scalable:
\series default
 use resources efficiently.
\end_layout

\begin_layout Itemize

\series bold
Concurrent:
\series default
 serve multiple simultaneous clients transparently.
\end_layout

\begin_layout Subsubsection*
Internals
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/db-components.png
	width 50text%

\end_inset


\end_layout

\begin_layout Paragraph
Usage Models
\end_layout

\begin_layout Itemize

\series bold
OLTP:
\series default
 online transaction processing: lots of small updates - want high throughput,
 ACID guarantees.
\end_layout

\begin_layout Itemize

\series bold
OLAP:
\series default
 online analytical processing: running a single data analysis task - want
 low latency, queries are ad-hoc.
\end_layout

\begin_layout Itemize

\series bold
Reporting:
\series default
 running many data analysis tasks in a fixed time - want good resource efficienc
y, queries known in advance.
\end_layout

\begin_layout Itemize

\series bold
HTAP:
\series default
 hybrid transactional/analytical processing.
\end_layout

\begin_layout Section
Storage
\end_layout

\begin_layout Paragraph
Storage manager
\end_layout

\begin_layout Standard
Needs to implement (at least):
\end_layout

\begin_layout Enumerate
Insert tuple.
\end_layout

\begin_layout Enumerate
Delete tuple by key.
\end_layout

\begin_layout Enumerate
Find tuple by key.
\end_layout

\begin_layout Paragraph
N-ary storage model
\end_layout

\begin_layout Itemize
Simply store full tuples in a vector.
\end_layout

\begin_layout Itemize
Insertion is as simple (append the tuple).
\end_layout

\begin_layout Itemize
Data locality is bad when retrieving.
\end_layout

\begin_layout Paragraph
Decomposed storage modeld
\end_layout

\begin_layout Itemize
Each column stored in a separate vector.
\end_layout

\begin_layout Itemize
Insertion now requires decomposition.
\end_layout

\begin_layout Itemize
Retrieving a single tuple requires reconstructing.
\end_layout

\begin_layout Paragraph
Metadata
\end_layout

\begin_layout Itemize
If the table is 
\emph on
dense
\emph default
 (all keys are consecutive), we can have constant lookups.
\end_layout

\begin_layout Itemize
If the table is 
\emph on
sorted
\emph default
, we can use binary search.
\end_layout

\begin_layout Section
Joins
\end_layout

\begin_layout Paragraph
Nested loop joins
\end_layout

\begin_layout Itemize
Sequential I/O
\end_layout

\begin_layout Itemize
Trivial to parallelize (no dependent loop iterations)
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Theta(|left|\times|right|)$
\end_inset

 with average effort of 
\begin_inset Formula $\frac{{|left|\times|right|}}{2}$
\end_inset

 assuming uniqueness
\end_layout

\begin_layout Paragraph
Sort-Merge Joins
\end_layout

\begin_layout Itemize
Sequential I/O in the merge phase
\end_layout

\begin_layout Itemize
\begin_inset Formula $O(|left|\times\log|left|+|right|\times\log|right|+|left|+|right|)$
\end_inset

 assuming uniqueness
\end_layout

\begin_layout Itemize
Works for inequality joins
\end_layout

\begin_layout Paragraph
Hash Joins
\end_layout

\begin_layout Standard
build-side 
\begin_inset Formula $\equiv$
\end_inset

 buffered side in the hashtable, probe-side 
\begin_inset Formula $\equiv$
\end_inset

 lookup the hashtable.
\end_layout

\begin_layout Itemize

\series bold
Hash function (CRC32, MurmurHash, Modulo-Division) requirements:
\series default
 
\bar under
pure
\bar default
 and 
\bar under
known
\bar default
, 
\bar under
contiguous
\bar default
 output domain.
 Nice to property to have: uniform
\end_layout

\begin_layout Itemize

\series bold
Handling conflicts requirements:
\series default
 Locality (to a certain extent), no holes (probe all the output domain)
\end_layout

\begin_layout Itemize
Sequential I/O the input.
 Parallelizable on probe side, research on build side
\end_layout

\begin_layout Itemize
\begin_inset Formula $O(|build|\times|probe|)$
\end_inset

 in the worst case, 
\begin_inset Formula $\Theta(|build|+|probe|)$
\end_inset

 in the best
\end_layout

\begin_layout Itemize

\series bold
Disadvantages: 
\series default
wastes space (over-allocated by 2), people generally rehash (not hole-free),
 hashing costs lots of CPU cycles (can be more expensive than memory), hashtable
s are probed randomly.
\end_layout

\begin_layout Paragraph
Probing strategies:
\end_layout

\begin_layout Standard
Consider the distance from the original conflict
\end_layout

\begin_layout Itemize

\series bold
Linear probing:
\series default
 try increasing distance by 1 until no conflict, leads to long probe chains
\end_layout

\begin_layout Itemize

\series bold
Quadratic probing:
\series default
 try doubling the distance until no conflict, good locality on first three
 probes and bad after, still likely to incur conflicts on first probes
\end_layout

\begin_layout Itemize

\series bold
Cyclic group probing:
\series default
 Generate a sequence of numbers while making sure every number in range
 is generated.
 
\begin_inset Formula $f(x)=(x\times g)\mod n$
\end_inset

 where 
\begin_inset Formula $n$
\end_inset

 is the size of the hashtable such that 
\begin_inset Formula $n=p^{k}$
\end_inset

, 
\begin_inset Formula $p$
\end_inset

 odd prime, 
\begin_inset Formula $\Rightarrow\exists g({primitive\;roots})$
\end_inset

 of 
\begin_inset Formula $p$
\end_inset

.
\end_layout

\begin_layout Paragraph
Partitioning
\end_layout

\begin_layout Standard
To make one relation much smaller than the other to fit in the buffer pool.
 Make use of the fact that sequential access is much cheaper than random
 access.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename img/partitioning.png
	width 50text%

\end_inset


\end_layout

\begin_layout Standard
The buffer pool above needs only to hold 5 pages at a time before flushing
 them to disk 
\begin_inset Formula $\Rightarrow$
\end_inset

 sequential I/O in partitioning.
 If partitioning is applied to the probe side to in such a way that matching
 tuples hash to the same value as the probe side then that will reduce massively
 the amount of work to do.
\end_layout

\begin_layout Paragraph
Block Nested Loop Joins
\end_layout

\begin_layout Standard
Simply brings better I/O behavior to NLJs, properties are similar otherwise.
\end_layout

\begin_layout Paragraph
Indexed Nested Loop Joins
\end_layout

\begin_layout Standard
One side has an index, scan over the other side and use the index to get
 the matching tuple
\end_layout

\begin_layout Itemize
Sequential I/O on the unindexed side, 
\bar under
Quasi
\bar default
-random on the indexed side
\end_layout

\begin_layout Itemize
Parallelizable over the values on the unindexed side
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Theta(|unidexed|\times|\log indexed|)$
\end_inset

, 
\begin_inset Formula $O(|left|\times|right|)$
\end_inset


\end_layout

\begin_layout Paragraph
Which algorithm to use
\end_layout

\begin_layout Itemize

\series bold
Sort-Merge join:
\series default
 if relations are sorted or have similar sizes.
 Or if evaluating inequality-joins
\end_layout

\begin_layout Itemize

\series bold
Index nested loops:
\series default
 if one relation has an index
\end_layout

\begin_layout Itemize

\series bold
Hashjoin 
\series default
if one relation is much smaller than the other (less than 10%)
\end_layout

\begin_layout Itemize

\series bold
Nested loops
\series default
 if one relation is tiny (
\begin_inset Formula $<20$
\end_inset

 values)
\end_layout

\begin_layout Itemize

\series bold
Block nested
\series default
 loops join for theta-joins
\end_layout

\begin_layout Section
Bulk Processing
\end_layout

\begin_layout Standard
Turn 
\bar under
control dependencies
\bar default
 into 
\bar under
data dependencies
\bar default
.
 No function calls (no jumps 
\begin_inset Formula $\Rightarrow$
\end_inset

 CPU efficient).
\end_layout

\begin_layout Quote
Page access probability from selectivity: 
\begin_inset Formula $1-(1-s)^{n}$
\end_inset


\end_layout

\begin_layout Itemize

\series bold
Materialise all:
\series default
 write down entire tuple in output array on each operator
\end_layout

\begin_layout Itemize

\series bold
By reference:
\series default
 Return array of reference to the Tuples in the table.
 
\end_layout

\begin_layout Itemize

\series bold
By reference using column storage (DSM):
\series default
 Same idea but optimises predicate evaluation by having more values fit
 on a page
\end_layout

\begin_layout Section
Secondary Storage
\end_layout

\begin_layout Subsection
Indexes
\end_layout

\begin_layout Itemize

\series bold
Clustered or Primary Index:
\series default
 store the tuples of a table, at most 1
\end_layout

\begin_layout Itemize

\series bold
Unclustered or Secondary Index:
\series default
 store pointers to the tuples of a table
\end_layout

\begin_layout Paragraph
Hash indexing
\end_layout

\begin_layout Standard
Hash table 
\begin_inset Formula $<\text{{Key}, \text{{Position}>}}$
\end_inset

 
\end_layout

\begin_layout Itemize

\series bold
Maintenance: 
\series default
Overallocated, need to rebuild if fill factor is too high (expensive even
 with 
\bar under
consistent hashing
\bar default
), on delete need to put a marker in the hashtable for future probing, load
 spikes
\end_layout

\begin_layout Itemize

\series bold
Usefulness:
\series default
 Equijoins/aggregation on specific keys, filter on specific keys
\end_layout

\begin_layout Paragraph
Bitmap indexing
\end_layout

\begin_layout Standard
A bitvector for each distinct value in a column (few distinct values) 
\end_layout

\begin_layout Itemize

\series bold
Usefulness:
\series default
 Can reduce bandwidth needed for scanning a column, can be compressed even
 further, can use arbitrary conditions (make disjoint sets of values called
 
\bar under
binned bitmaps
\bar default
)
\end_layout

\begin_layout Itemize

\series bold
Run-length encoding: 
\series default
replace consecutive occurrences with length of the chain, works well on
 high locality data, requires sequential scan to find values at a specific
 position
\end_layout

\begin_layout Paragraph
Foreign-Key indices
\end_layout

\begin_layout Standard
Specifies that there is 
\bar under
exactly one
\series bold
\bar default
 
\series default
value in the PK column of the other table
\end_layout

\begin_layout Itemize
Need to maintain integrity, DBMS on insert/update need to make sure the
 value doesn't already exist
\end_layout

\begin_layout Itemize
Implemented using a pointer because it means it joins to exactly one row
\end_layout

\begin_layout Itemize

\series bold
Usefulness: Low space requirement, instant joins, insignificant effort added
 on insert/update.

\series default
 But can't be used for anything else
\end_layout

\begin_layout Paragraph
B-Trees
\end_layout

\begin_layout Standard
Reduce load spikes by using a tree
\end_layout

\begin_layout Itemize

\series bold
Usefulness:
\series default
 Support ranges, self balancing 
\end_layout

\begin_layout Itemize

\series bold
Disadvantages:
\series default
 Complex, leaf pointers aren't used, most of the data lives in the leaf
 nodes but not all of it (need to go up)
\end_layout

\begin_layout Paragraph
B+-Trees
\end_layout

\begin_layout Standard
Keep all key and pointers to data in the leaf nodes, replicate the keys
 above, link the leaves like a linked list.
\end_layout

\begin_layout Itemize

\series bold
Usefulness:
\series default
 balancing is same effort, dense index at the bottom (sequential access),
 scans over ranges are trivial
\end_layout

\begin_layout Subsection
Materialized views
\end_layout

\begin_layout Itemize
\begin_inset Formula $\equiv$
\end_inset

 alias to a query.
 However some systems actually stores the result of the query and modify
 it on modifications of the underlying relations (expensive).
\end_layout

\begin_layout Itemize

\series bold
Usefulness:
\series default
 Running the same query returns result instantaneously, some systems are
 smart in reusing part of the views to save on computation
\end_layout

\begin_layout Section
Concurrency Control
\end_layout

\begin_layout Standard
DBMS implements indivisible tasks (
\emph on
transactions
\emph default
):
\end_layout

\begin_layout Enumerate

\emph on
Atomicity
\emph default
: all or nothing.
\end_layout

\begin_layout Enumerate

\emph on
Consistency
\emph default
: consistent before 
\begin_inset Formula $\rightarrow$
\end_inset

 consistent after.
\end_layout

\begin_layout Enumerate

\emph on
Isolation
\emph default
: independent of any other transaction.
\end_layout

\begin_layout Enumerate

\emph on
Durability
\emph default
: completed transactions are durable.
\end_layout

\end_body
\end_document

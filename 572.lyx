#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass paper
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family sfdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a5paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1cm
\topmargin 1.2cm
\rightmargin 1cm
\bottommargin 1.2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle empty
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
CO572 Advanced Databases
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Database management systems
\end_layout

\begin_layout Paragraph
Requirements
\end_layout

\begin_layout Standard
Should provide:
\end_layout

\begin_layout Itemize

\emph on
Storage
\emph default
: single, reliable repository of data.
\end_layout

\begin_layout Itemize

\emph on
Transactions
\emph default
: should be atomic, consistent, isolated, durable.
\end_layout

\begin_layout Itemize

\emph on
Data analysis
\emph default
.
\end_layout

\begin_layout Itemize

\emph on
Programming model
\emph default
.
\end_layout

\begin_layout Standard
In a way that is:
\end_layout

\begin_layout Itemize

\emph on
Efficient
\emph default
: not slower than hand-written applications.
\end_layout

\begin_layout Itemize

\emph on
Resilient
\emph default
: should recover from problems.
\end_layout

\begin_layout Itemize

\emph on
Robust
\emph default
: predictable performance.
\end_layout

\begin_layout Itemize

\emph on
Scalable
\emph default
: use resources efficiently.
\end_layout

\begin_layout Itemize

\emph on
Concurrent
\emph default
: serve multiple simultaneous clients transparently.
\end_layout

\begin_layout Subsubsection*
Internals
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/db-components.png
	width 50text%

\end_inset


\end_layout

\begin_layout Paragraph
Usage Models
\end_layout

\begin_layout Itemize

\series bold
OLTP:
\series default
 online transaction processing: lots of small updates - want high throughput,
 ACID guarantees.
\end_layout

\begin_layout Itemize

\series bold
OLAP:
\series default
 online analytical processing: running a single data analysis task - want
 low latency, queries are ad-hoc.
\end_layout

\begin_layout Itemize

\series bold
Reporting:
\series default
 running many data analysis tasks in a fixed time - want good resource efficienc
y, queries known in advance.
\end_layout

\begin_layout Itemize

\series bold
HTAP:
\series default
 hybrid transactional/analytical processing.
\end_layout

\begin_layout Section
Storage
\end_layout

\begin_layout Paragraph
Storage manager
\end_layout

\begin_layout Standard
Needs to implement (at least):
\end_layout

\begin_layout Enumerate
Insert tuple.
\end_layout

\begin_layout Enumerate
Delete tuple by key.
\end_layout

\begin_layout Enumerate
Find tuple by key.
\end_layout

\begin_layout Paragraph
N-ary storage model
\end_layout

\begin_layout Itemize
Simply store full tuples in a vector.
\end_layout

\begin_layout Itemize
Insertion is as simple (append the tuple).
\end_layout

\begin_layout Itemize
Data locality is bad when retrieving.
\end_layout

\begin_layout Paragraph
Decomposed storage model
\end_layout

\begin_layout Itemize
Each column stored in a separate vector.
\end_layout

\begin_layout Itemize
Insertion now requires decomposition (more complicated, requires random
 access).
\end_layout

\begin_layout Itemize
Retrieving a single tuple requires reconstructing.
\end_layout

\begin_layout Paragraph
Metadata
\end_layout

\begin_layout Itemize
If the table is 
\emph on
dense
\emph default
 (all keys are consecutive), we can have constant lookups.
\end_layout

\begin_layout Itemize
If the table is 
\emph on
sorted
\emph default
, we can use binary search.
\end_layout

\begin_layout Paragraph
Hybrid storage: Delta/Main
\end_layout

\begin_layout Itemize
Main storage uses DSM.
\end_layout

\begin_layout Itemize
Delta storage uses NSM.
\end_layout

\begin_layout Itemize
Periodically merge delta into main.
\end_layout

\begin_layout Paragraph
Variable-sized datatypes
\end_layout

\begin_layout Enumerate

\emph on
In-place storage
\emph default
: overallocate space.
\end_layout

\begin_deeper
\begin_layout Itemize
Good for locality.
\end_layout

\begin_layout Itemize
Simple.
\end_layout

\begin_layout Itemize
Wastes space.
\end_layout

\end_deeper
\begin_layout Enumerate

\emph on
Out of place storage
\emph default
: key into a dictionary.
\end_layout

\begin_deeper
\begin_layout Itemize
Space conservative (we can even do dictionary compression).
\end_layout

\begin_layout Itemize
Bad for locality.
\end_layout

\begin_layout Itemize
Complicated (hard to implement: garbage-collection).
\end_layout

\end_deeper
\begin_layout Paragraph
Disks
\end_layout

\begin_layout Enumerate
Larger pages.
\end_layout

\begin_layout Enumerate
Much higher latency (ms vs ns).
\end_layout

\begin_layout Enumerate
Much lower throughput.
\end_layout

\begin_layout Enumerate
OS gets in the way (filesize is limited).
\end_layout

\begin_layout Standard
Change of goals:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/db-kernel.png
	width 70text%

\end_inset


\end_layout

\begin_layout Enumerate
Complicated I/O management strategies pay off.
\end_layout

\begin_layout Enumerate
Pages are large: we use a 
\emph on
buffer manager
\emph default
 to manage pages for a relation.
\end_layout

\begin_layout Paragraph
Pages
\end_layout

\begin_layout Enumerate

\emph on
Unspanned pages
\emph default
:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/unspanned-pages.png
	width 50text%

\end_inset


\end_layout

\begin_layout Itemize
Simple.
\end_layout

\begin_layout Itemize
Assuming known page fill-factors, we can always lookup an ID with a single
 page lookup.
\end_layout

\begin_layout Itemize
Wastes space.
\end_layout

\begin_layout Itemize
Cannot deal with large records.
\end_layout

\begin_layout Itemize
No in-page random access for variable sized records.
\end_layout

\end_deeper
\begin_layout Enumerate

\emph on
Spanned pages
\emph default
:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/spanned-pages.png
	width 50text%

\end_inset


\end_layout

\begin_layout Itemize
Minimises space waste.
\end_layout

\begin_layout Itemize
Supports large records.
\end_layout

\begin_layout Itemize
Complicated.
\end_layout

\begin_layout Itemize
Random access performance worsened.
\end_layout

\begin_layout Itemize
No in-page random access for variable-sized records.
\end_layout

\end_deeper
\begin_layout Enumerate

\emph on
Slotted pages
\emph default
:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/slotted-pages.png
	width 30text%

\end_inset


\end_layout

\begin_layout Itemize
Store tuples in in-place n-ary format.
\end_layout

\begin_layout Itemize
Store tuple count in page header.
\end_layout

\begin_layout Itemize
Store offsets to every tuple.
 Only need to be large enough to address page.
\end_layout

\end_deeper
\begin_layout Standard
Dictionaries usually kept in-page:
\end_layout

\begin_layout Itemize
Solves problem of variable sized records.
\end_layout

\begin_layout Itemize
Avoids needless page faults.
\end_layout

\begin_layout Itemize
Allows duplicate elimination.
\end_layout

\begin_layout Section
Querying
\end_layout

\begin_layout Enumerate

\emph on
Vector
\emph default
: ordered collection of objects of the same type.
\end_layout

\begin_layout Enumerate

\emph on
Tuple
\emph default
: unordered collection of objects of different type.
\end_layout

\begin_layout Enumerate

\emph on
Bag
\emph default
: unordered collection of objects of the same type.
\end_layout

\begin_layout Enumerate

\emph on
Set
\emph default
: unordered collection of unique objects of the same type.
\end_layout

\begin_layout Paragraph
Relational algebra
\end_layout

\begin_layout Standard
\begin_inset Formula $\pi_{\text{attr}s}\left(A\right)$
\end_inset

, 
\begin_inset Formula $\sigma_{\text{pred}}\left(A\right)$
\end_inset

, 
\begin_inset Formula $A\times B$
\end_inset

, 
\begin_inset Formula $A\cup B$
\end_inset

, 
\begin_inset Formula $\Gamma_{\text{(attrs, (attr, aggregate, name))}}$
\end_inset

, 
\begin_inset Formula $\tau_{\text{(n, attr)}}$
\end_inset

.
\end_layout

\begin_layout Section
Processing models
\end_layout

\begin_layout Paragraph
Volcano processing
\end_layout

\begin_layout Itemize
Easy to implement: focus on flexibility, clean design, maintainability,
 developer productivity.
\end_layout

\begin_layout Itemize

\emph on
Extensible
\emph default
: easy to add new operators.
\end_layout

\begin_layout Itemize

\emph on
Good I/O behaviour
\emph default
: tuples consumed as they are produced.
\end_layout

\begin_layout Itemize

\emph on
Poor CPU usage
\emph default
: function pointers cause control hazards.
\end_layout

\begin_layout Itemize
Uses 
\family typewriter
open()
\family default
, 
\family typewriter
next()
\family default
 and 
\family typewriter
close()
\family default
 methods.
\end_layout

\begin_layout Enumerate

\emph on
Scan
\emph default
: 
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
open()
\family default
: open file.
\end_layout

\begin_layout Itemize

\family typewriter
next()
\family default
: read next item (better: use a buffer manager to keep just the page you
 need open).
\end_layout

\begin_layout Itemize

\family typewriter
close()
\family default
: close file.
\end_layout

\end_deeper
\begin_layout Enumerate

\emph on
Projection
\emph default
: 
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
open()
\family default
: open input.
\end_layout

\begin_layout Itemize

\family typewriter
next()
\family default
: call 
\family typewriter
next()
\family default
, apply projection function.
\end_layout

\begin_layout Itemize

\family typewriter
close()
\family default
: close input.
\end_layout

\end_deeper
\begin_layout Enumerate

\emph on
Selection
\emph default
: 
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
open()
\family default
: open input.
\end_layout

\begin_layout Itemize

\family typewriter
next()
\family default
: call 
\family typewriter
next()
\family default
 on input until an item qualifies.
\end_layout

\begin_layout Itemize

\family typewriter
close()
\family default
: close input.
\end_layout

\end_deeper
\begin_layout Enumerate

\emph on
Union
\emph default
: 
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
open()
\family default
: open inputs.
\end_layout

\begin_layout Itemize

\family typewriter
next()
\family default
: call 
\family typewriter
next()
\family default
 on left input, or right input if we reach the end of LHS.
\end_layout

\begin_layout Itemize

\family typewriter
close()
\family default
: close inputs.
\end_layout

\end_deeper
\begin_layout Enumerate

\emph on
Difference
\emph default
: 
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
open()
\family default
: buffer the right input, and open the left.
\end_layout

\begin_layout Itemize

\family typewriter
next()
\family default
: call 
\family typewriter
next()
\family default
 on left input until an item is not in the buffer.
\end_layout

\begin_layout Itemize

\family typewriter
close()
\family default
: close left input.
\end_layout

\end_deeper
\begin_layout Enumerate

\emph on
Cross
\emph default
 (pipeline-breaking): 
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
open()
\family default
: buffer the right input, and open the left.
\end_layout

\begin_layout Itemize

\family typewriter
next()
\family default
: combine each left input with every right input (by keeping a pointer to
 buffer pos), then call 
\family typewriter
next()
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
close()
\family default
: close left input.
\end_layout

\end_deeper
\begin_layout Enumerate

\emph on
Cross
\emph default
 (streaming): 
\end_layout

\begin_deeper
\begin_layout Itemize
Return first results whilst buffering the RHS.
\end_layout

\end_deeper
\begin_layout Enumerate

\emph on
Grouped aggregation
\emph default
: 
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
open()
\family default
: read through the tuples, get the group keys, calculate the hash value,
 apply aggregate function and place in hash table.
\end_layout

\begin_layout Itemize

\family typewriter
next()
\family default
: iterate through hash table slots.
\end_layout

\end_deeper
\begin_layout Paragraph
Pipeline breakers
\end_layout

\begin_layout Standard
Operators that produces the first correct output only after all input tuples
 have been processed:
\end_layout

\begin_layout Itemize

\emph on
Scan
\emph default
, 
\emph on
selection
\emph default
, 
\emph on
project
\emph default
, 
\emph on
union
\emph default
 are not pipeline breakers.
\end_layout

\begin_layout Itemize

\emph on
Difference
\emph default
, 
\emph on
grouping
\emph default
 are pipeline breakers.
\end_layout

\begin_layout Itemize

\emph on
Cross product
\emph default
, 
\emph on
join
\emph default
 are often implemented as a pipeline breaker.
\end_layout

\begin_layout Paragraph
Buffer I/O in Volcano
\end_layout

\begin_layout Enumerate

\emph on
Scans
\emph default
: sequenetial I/O of all pages in relation.
\end_layout

\begin_layout Enumerate

\emph on
Pipeline breakers
\emph default
: 
\family typewriter
open()
\family default
: if buffer fits in memory, no I/O, otherwise sequential / random (assume
 one page per access) I/O.
\end_layout

\begin_layout Enumerate

\emph on
Pipeline breakers
\emph default
: 
\family typewriter
next()
\family default
: if buffer fits in memory, no I/O, otherwise sequential I/O over buffer.
\end_layout

\begin_layout Paragraph
Function calls in Volcano
\end_layout

\begin_layout Enumerate

\emph on
Selections and prjections
\emph default
: one to red input, one to apply predicate.
\end_layout

\begin_layout Enumerate

\emph on
Cross product
\emph default
: one to read inner input, one to read outer input.
\end_layout

\begin_layout Enumerate

\emph on
Group by
\emph default
: one to read input, one to extract group key, one to calculate each new
 aggregate value.
\end_layout

\begin_layout Section
Joins
\end_layout

\begin_layout Paragraph
Nested loop join
\end_layout

\begin_layout Itemize
Simple.
\end_layout

\begin_layout Itemize
Sequential I/O.
\end_layout

\begin_layout Itemize
Trivial to parallelize (no dependent loop iterations).
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Theta(|left|\times|right|)$
\end_inset

 with average effort of 
\begin_inset Formula $\frac{{|left|\times|right|}}{2}$
\end_inset

 assuming uniqueness
\end_layout

\begin_layout Paragraph
Sort-merge join
\end_layout

\begin_layout Standard
Requires sortedness.
 Works for inequality joins.
\end_layout

\begin_layout Itemize
Sequential I/O in the merge phase.
\end_layout

\begin_layout Itemize
Tricky to parallelize.
\end_layout

\begin_layout Itemize
\begin_inset Formula $O(|left|\times\log|left|+|right|\times\log|right|+|left|+|right|)$
\end_inset

 assuming uniqueness.
\end_layout

\begin_layout Paragraph
Hash join
\end_layout

\begin_layout Standard
Build-side is the buffered side in the hashtable, probe-side is the lookup
 the hashtable.
\end_layout

\begin_layout Itemize

\emph on
Hash function
\emph default
 (e.g.
 Modulo-Division) 
\emph on
requirements
\emph default
:
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
Pure
\emph default
: no state.
\end_layout

\begin_layout Itemize

\emph on
Known
\emph default
 ouptut domain.
\end_layout

\begin_layout Itemize

\emph on
Contiguous
\emph default
 output domain: no holes in output domain.
\end_layout

\begin_layout Itemize
Nice to property to have: 
\emph on
uniform
\emph default
.
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Handling conflicts requirements
\emph default
:
\end_layout

\begin_deeper
\begin_layout Itemize
Locality (to some extent).
\end_layout

\begin_layout Itemize
No holes (probe all the output domain)
\end_layout

\end_deeper
\begin_layout Itemize
Sequential I/O on the inputs.
\end_layout

\begin_layout Itemize
Parallelizable on probe side.
\end_layout

\begin_layout Itemize
\begin_inset Formula $O(|build|\times|probe|)$
\end_inset

 in the worst case, 
\begin_inset Formula $\Theta(|build|+|probe|)$
\end_inset

 in the best.
\end_layout

\begin_layout Itemize

\emph on
Disadvantages
\emph default
:
\end_layout

\begin_deeper
\begin_layout Itemize
Wastes space (over-allocated by at least 2).
\end_layout

\begin_layout Itemize
People generally rehash (not hole-free), hashing costs lots of CPU cycles
 (can be more expensive than memory).
\end_layout

\begin_layout Itemize
Probing is random access! If table doesn't fit into buffer pool 
\begin_inset Formula $\implies$
\end_inset

 lots of I/O.
\end_layout

\end_deeper
\begin_layout Itemize
Often use buckets for slots.
\end_layout

\begin_layout Paragraph
Probing strategies
\end_layout

\begin_layout Standard
Consider the distance from the original conflict
\end_layout

\begin_layout Enumerate

\emph on
Linear probing
\emph default
: try increasing distance by 1 until no conflict.
\end_layout

\begin_deeper
\begin_layout Itemize
Leads to long probe chains.
\end_layout

\end_deeper
\begin_layout Enumerate

\emph on
Quadratic probing
\emph default
: try doubling the distance until no conflict.
\end_layout

\begin_deeper
\begin_layout Itemize
Good locality on first three probes and bad after.
\end_layout

\begin_layout Itemize
Still likely to incur conflicts on first probes.
\end_layout

\end_deeper
\begin_layout Enumerate

\emph on
Cyclic group probing
\emph default
: Generate a sequence of numbers while making sure every number in range
 is generated.
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $f(x)=(x\times g)\mod n$
\end_inset

 where:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $n$
\end_inset

 is the size of the hashtable such that 
\begin_inset Formula $n=p^{k}$
\end_inset

 for odd prime 
\begin_inset Formula $p$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $g$
\end_inset

 is a primite root of 
\begin_inset Formula $p$
\end_inset

 (difficult to find).
\end_layout

\end_deeper
\end_deeper
\begin_layout Paragraph
Partitioning
\end_layout

\begin_layout Standard
Improves the performance of the probe-side of a join.
\end_layout

\begin_layout Itemize
Requires additional scans over the larger relation.
\end_layout

\begin_layout Itemize
Ensures sequential I/O.
\end_layout

\begin_layout Itemize
Easy to parallelize.
\end_layout

\begin_layout Itemize
We can partition the larger relation too, and only join overlapping partitions...
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename ../tyn/img/partitioning.png
	width 65text%

\end_inset


\end_layout

\begin_layout Paragraph
Block nested loops join
\end_layout

\begin_layout Standard
Nested loops join, but scan per LHS page, rather than tuple.
\end_layout

\begin_layout Paragraph
Indexed nested loop join
\end_layout

\begin_layout Standard
One side has an index, scan over the other side and use the index to get
 the matching tuple.
\end_layout

\begin_layout Itemize
Sequential I/O on the unindexed side.
\end_layout

\begin_layout Itemize
Quasi-random on the indexed side.
\end_layout

\begin_layout Itemize
Parallelizable over the values on the unindexed side
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Theta(|unidexed|\times|\log indexed|)$
\end_inset

.
\end_layout

\begin_layout Paragraph
Which algorithm to use
\end_layout

\begin_layout Itemize

\emph on
Sort-merge join
\emph default
: if relations are sorted or have similar sizes.
 Or if evaluating inequality-joins.
\end_layout

\begin_layout Itemize

\emph on
Index nested loops
\emph default
: if one relation has an index.
\end_layout

\begin_layout Itemize

\emph on
Hash join
\emph default
:
\series bold
 
\series default
if one relation is much smaller than the other (less than 10%).
\end_layout

\begin_layout Itemize

\emph on
Nested loops
\emph default
: if one relation is tiny (< 20 values).
\end_layout

\begin_layout Itemize

\emph on
Block nested
\emph default
: loops join for theta-joins.
\end_layout

\begin_layout Section
Bulk Processing
\end_layout

\begin_layout Standard
Turn 
\emph on
control dependencies
\emph default
 into 
\emph on
data dependencies
\emph default
.
 No function calls (no jumps 
\begin_inset Formula $\Rightarrow$
\end_inset

 CPU efficient).
\end_layout

\begin_layout Quote
Page access probability from selectivity: 
\begin_inset Formula $1-(1-s)^{n}$
\end_inset


\end_layout

\begin_layout Itemize

\emph on
Materialise all
\emph default
: write down entire tuple in output array on each operator.
\end_layout

\begin_layout Itemize

\emph on
By reference
\emph default
: return array of reference to the Tuples in the table.
 
\end_layout

\begin_layout Itemize

\emph on
By reference using column storage (DSM)
\emph default
: same idea but optimises predicate evaluation by having more values fit
 on a page
\end_layout

\begin_layout Section
Secondary Storage
\end_layout

\begin_layout Paragraph
Indices
\end_layout

\begin_layout Itemize

\emph on
Clustered or Primary Index
\emph default
: store the tuples of a table, at most 1,
\end_layout

\begin_layout Itemize

\emph on
Unclustered or Secondary Index
\emph default
: store pointers to the tuples of a table.
\end_layout

\begin_layout Paragraph
Hash indexing
\end_layout

\begin_layout Standard
Hash table rom key 
\begin_inset Formula $\rightarrow$
\end_inset

 position.
\end_layout

\begin_layout Itemize

\emph on
Maintenance
\emph default
:
\end_layout

\begin_deeper
\begin_layout Itemize
Overallocate by a lot.
\end_layout

\begin_layout Itemize
Need to rebuild if fill factor is too high (expensive even with consistent
 hashing).
\end_layout

\begin_layout Itemize
On delete need to put a marker in the hashtable for future probing.
\end_layout

\begin_layout Itemize
Load spikes 
\begin_inset Formula $\frownie$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Useful
\emph default
 
\emph on
for
\emph default
:
\end_layout

\begin_deeper
\begin_layout Itemize
Equi-joins, aggregation on specific keys.
\end_layout

\begin_layout Itemize
Filter on specific keys.
\end_layout

\end_deeper
\begin_layout Paragraph
Bitmap indexing
\end_layout

\begin_layout Standard
A bitvector for each distinct value in a column (few distinct values).
\end_layout

\begin_layout Itemize

\emph on
Run-length encoding
\emph default
: replace consecutive occurrences with length of the chain.
\end_layout

\begin_deeper
\begin_layout Itemize
Works well on high locality data.
\end_layout

\begin_layout Itemize
Requires sequential scan to find values at a specific position.
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Useful for
\emph default
:
\end_layout

\begin_deeper
\begin_layout Itemize
Can reduce bandwidth needed for scanning a column.
\end_layout

\begin_layout Itemize
Can use arbitrary conditions (make disjoint sets of values called binned
 bitmaps).
\end_layout

\end_deeper
\begin_layout Paragraph
Foreign-Key indices
\end_layout

\begin_layout Standard
Specifies that there is exactly one
\series bold
 
\series default
value in the PK column of the other table
\end_layout

\begin_layout Itemize
Need to maintain integrity, DBMS on insert/update need to make sure the
 value doesn't already exist.
\end_layout

\begin_layout Itemize
Implemented using a pointer because it means it joins to exactly one row.
\end_layout

\begin_layout Itemize

\emph on
Advantages
\emph default
:
\end_layout

\begin_deeper
\begin_layout Itemize
Low space requirement.
\end_layout

\begin_layout Itemize
Instant joins.
\end_layout

\begin_layout Itemize
Insignificant effort added on insert/update.
\end_layout

\end_deeper
\begin_layout Paragraph
B-Trees
\end_layout

\begin_layout Standard
Reduce load spikes by using a tree.
\end_layout

\begin_layout Itemize

\emph on
Advantages
\emph default
: Support ranges, self balancing 
\end_layout

\begin_layout Itemize

\emph on
Disadvantages
\emph default
: Complex, leaf pointers aren't used, most of the data lives in the leaf
 nodes but not all of it (need to go up).
\end_layout

\begin_layout Standard

\emph on
Insertion
\emph default
:
\end_layout

\begin_layout Enumerate
Find the right leaf-node to insert.
\end_layout

\begin_layout Enumerate
If the node overflows, split the node into two halves, choose the median
 to go in the parent.
\end_layout

\begin_layout Paragraph
B+-Trees
\end_layout

\begin_layout Standard
Keep all key and pointers to data in the leaf nodes, replicate the keys
 above, link the leaves like a linked list.
\end_layout

\begin_layout Itemize

\emph on
Advantages
\emph default
: scans over ranges are trivial.
\end_layout

\begin_layout Paragraph
Materialized views
\end_layout

\begin_layout Itemize
Basically alias to a query.
 
\end_layout

\begin_deeper
\begin_layout Itemize
Some systems actually stores the result of the query and modify it on modificati
ons of the underlying relations (expensive).
\end_layout

\begin_layout Itemize

\emph on
Useful for
\emph default
: running the same query returns result instantaneously.
\end_layout

\end_deeper
\begin_layout Section
Query Planning and Optimisation
\end_layout

\begin_layout Standard
Start with a correct plan and apply equivalence rules.
\end_layout

\begin_layout Itemize
From the root of the plan, apply pattern to start new plan and start process
 again until you traverse without applying any transformation.
\end_layout

\begin_layout Itemize

\emph on
Logical
\emph default
: algorithm-agnostic.
\end_layout

\begin_layout Itemize

\emph on
Physical
\emph default
: algorithm-aware.
\end_layout

\begin_layout Itemize

\emph on
Rule-based
\emph default
: data-agnostic.
\end_layout

\begin_layout Itemize

\emph on
Cost-based
\emph default
: data-aware.
\end_layout

\begin_layout Paragraph
Logical rule-based optimization
\end_layout

\begin_layout Standard
Simple and portable, but sometimes wrong, infinite cycles, missing rules.
\end_layout

\begin_layout Itemize
Selection and projection 
\series bold
pushed
\series default
 through joins if only applied to one side
\end_layout

\begin_layout Itemize

\series bold
Operator reordering
\series default
 (joins, selection, unions) using a heuristic like 
\begin_inset Formula $s(==)<s(<)<s(<>)$
\end_inset

.
\end_layout

\begin_layout Paragraph
Cost-based optimisation
\end_layout

\begin_layout Standard
Cost metric could be number of tuples produced.
\end_layout

\begin_layout Itemize

\emph on
Estimations
\emph default
: like selecting one value: 
\begin_inset Formula $\frac{1}{\text{disctinct values in column}}$
\end_inset

 and recording distinct values are brittle.
\end_layout

\begin_layout Itemize

\emph on
Statistics
\emph default
: use histograms 
\begin_inset Formula $\frac{\text{ocurrences of a value}}{\text{total tuple count}}$
\end_inset

 and evaluate query on histogram first.
\end_layout

\begin_layout Itemize

\emph on
Multidimensional histograms
\emph default
 used to resolve attribute correlation.
\end_layout

\begin_layout Paragraph
Physical optimisation
\end_layout

\begin_layout Itemize

\series bold
Example metrics:
\series default
 number of function calls, sum of all produced tuples (incl.
 materializations), number of page faults (I/O), CPU costs, max(I/O, CPU),
 total intermediate size, ...
\end_layout

\begin_layout Itemize

\series bold
Counting cost is hard:
\series default
 different algorithms have different costs on all the above, how do you
 weight them?
\end_layout

\begin_layout Paragraph
Rule based physical optimisation
\end_layout

\begin_layout Standard
Focused on hardware (parallelism, cache-conscious partitioning).
\end_layout

\begin_layout Paragraph
Cost-based physical optimisation
\end_layout

\begin_layout Standard
Generally access path selection: from base table, indices, etc.
\end_layout

\begin_layout Section
Distributed databases
\end_layout

\begin_layout Paragraph
CAP theory
\end_layout

\begin_layout Standard
No distributed system can maintain all three:
\end_layout

\begin_layout Enumerate

\emph on
Consistency
\emph default
: all nodes see the same version of data.
\end_layout

\begin_layout Enumerate

\emph on
Availability
\emph default
: system always responds within fixed upper limit of time.
\end_layout

\begin_layout Enumerate

\emph on
Partition tolerance
\emph default
: system always gives correct response even when messages are lost.
\end_layout

\begin_layout Paragraph
Approaches
\end_layout

\begin_layout Enumerate

\emph on
Heterogeneous DDB
\emph default
: varied database techology, managed by different DBAs, designed at different
 times.
\end_layout

\begin_deeper
\begin_layout Itemize
Requires a 
\emph on
commmon data model
\end_layout

\begin_layout Itemize
Need to perform 
\emph on
schema integration
\emph default
.
\end_layout

\begin_layout Enumerate
Transform 
\emph on
local schemas
\emph default
 to a standard data modelling language.
\end_layout

\begin_layout Enumerate
Filter to get 
\emph on
export schemas
\emph default
.
\end_layout

\begin_layout Enumerate
Construct 
\emph on
global schemas
\emph default
.
\end_layout

\begin_layout Enumerate
Filter to get 
\emph on
external schema
\emph default
 for applications.
\end_layout

\begin_layout Itemize

\emph on
Data warehouse
\emph default
: materialise copies of data with global schema.
\end_layout

\begin_layout Itemize

\emph on
Mediator architecture
\emph default
: gives live results, but higher latency and demand on systems.
\end_layout

\end_deeper
\begin_layout Enumerate

\emph on
Homogeneous DDB
\emph default
: same technology, one DBA, designed at same time.
\end_layout

\begin_deeper
\begin_layout Itemize
Different sites each have 
\emph on
local schema
\emph default
.
\end_layout

\begin_layout Itemize
Combine to form a single 
\emph on
global schema
\emph default
.
\end_layout

\begin_layout Itemize
Different 
\emph on
external schemas
\emph default
 for different applications.
\end_layout

\end_deeper
\begin_layout Paragraph
Fragmentation / sharding
\end_layout

\begin_layout Standard
Split data objects between sites, queries and updates correspondingly distribute
d.
\end_layout

\begin_layout Itemize
Usually less reliable (each database can go down).
\end_layout

\begin_layout Itemize
Usually faster (parallelism in horizontal fragmentation).
\end_layout

\begin_layout Enumerate

\emph on
Horizontal fragmentation
\emph default
:
\begin_inset Formula 
\[
R=R_{1}\cup\dots\cup R_{n}
\]

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Split rows using 
\begin_inset Formula $\sigma$
\end_inset

:
\begin_inset Formula 
\[
R_{1}=\sigma_{P_{1}}R,\dots,R_{n}=\sigma_{P_{n}}R
\]

\end_inset


\end_layout

\begin_layout Itemize
Derived horizontal fragmentation splits rows using 
\begin_inset Formula $\ltimes$
\end_inset

:
\begin_inset Formula 
\[
R_{1}=R\ltimes S_{1},\dots,R\ltimes S_{n}
\]

\end_inset


\end_layout

\begin_layout Itemize
Fragmentation rules:
\end_layout

\begin_deeper
\begin_layout Enumerate
Must cover all possible values.
\end_layout

\begin_layout Enumerate
Should not involve things that change!
\end_layout

\begin_layout Enumerate
Should be easy to fragment on.
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\emph on
Vertical fragmentation
\emph default
: A loss-less join decomposition:
\begin_inset Formula 
\[
R=R_{1}\bowtie\dots\bowtie R_{n}
\]

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Splits rows using 
\begin_inset Formula $\pi$
\end_inset

:
\begin_inset Formula 
\[
R_{1}=\pi_{\text{attrs}_{1}}R,\dots,R_{n}=\pi_{\text{attrs}_{n}}R
\]

\end_inset


\end_layout

\begin_layout Itemize
Fragmentation rule should include a key.
\end_layout

\end_deeper
\begin_layout Paragraph
Replication
\end_layout

\begin_layout Standard
Copy data objects between sites.
\end_layout

\begin_layout Itemize
Queries may run on any site.
\end_layout

\begin_layout Itemize
Updates must be written to all sites.
\end_layout

\begin_layout Itemize
Usually more reliable (individual copies may go down).
\end_layout

\begin_layout Itemize
Usually faster (by reducing load on each site).
\end_layout

\begin_layout Paragraph
Migration
\end_layout

\begin_layout Standard
Move data to where its used.
\end_layout

\begin_layout Section
Big data
\end_layout

\begin_layout Paragraph
Data models
\end_layout

\begin_layout Itemize

\emph on
Key-value.
\end_layout

\begin_deeper
\begin_layout Itemize
Schema-less.
\end_layout

\begin_layout Itemize
Very limited querying capabalities.
\end_layout

\begin_layout Itemize
Useful for caching.
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Document store
\emph default
: document (semi-structured) data model (e.g.
 JSON).
\end_layout

\begin_deeper
\begin_layout Itemize
Schema-less.
\end_layout

\begin_layout Itemize
Support queries searching field values.
\end_layout

\begin_layout Itemize
Use MapReduce for OLAP.
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Wide column
\emph default
: table data model with easy addition of new columns.
 Columns may be put in families.
\end_layout

\begin_deeper
\begin_layout Itemize
Schema-less.
\end_layout

\begin_layout Itemize
Support queries searching field values.
\end_layout

\begin_layout Itemize
Use MapReduce for OLAP.
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Relational
\emph default
: relational data model.
\end_layout

\begin_deeper
\begin_layout Itemize
Schema based.
\end_layout

\begin_layout Itemize
Support queries searching fields and performing joins.
\end_layout

\begin_layout Itemize
ACID properties of transactions.
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Graph
\emph default
: nodes and edges (e.g.
 RDF).
\end_layout

\begin_deeper
\begin_layout Itemize
Schema-less.
\end_layout

\begin_layout Itemize
Limited querying possible.
\end_layout

\end_deeper
\begin_layout Paragraph
MapReduce
\end_layout

\begin_layout Enumerate

\emph on
Load
\emph default
: items from data nodes to Map nodes.
\end_layout

\begin_layout Enumerate

\emph on
Map
\emph default
: nodes perform map function on each item.
\end_layout

\begin_layout Enumerate

\emph on
Combine
\emph default
: partially calculate the Reduce on the Map nodes.
\end_layout

\begin_layout Enumerate

\emph on
Shuffle
\emph default
: send each item to the correct Reduce node.
\end_layout

\begin_layout Enumerate

\emph on
Reduce
\emph default
: nodes perform reduction function on incoming items.
\end_layout

\begin_layout Paragraph
Pig Latin
\end_layout

\begin_layout Itemize

\emph on
Load
\emph default
: make data source available as relation:
\family typewriter

\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

account = LOAD 'file.tsv'
\end_layout

\begin_layout Plain Layout

          AS (no:int, type:chararray, rate:float);
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Strore
\emph default
: execute script and store result:
\family typewriter

\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

STORE account INTO 'copy' USING PigStorage(',');
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Project
\emph default
: 
\family typewriter

\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

rate = FOREACH account GENERATE rate;
\end_layout

\begin_layout Plain Layout

distinct_rate = DISTINCT rate;
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Filter
\emph default
:
\family typewriter

\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

account_with_rate = FILTER account BY rate > 0.0;
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Cross
\emph default
:
\family typewriter

\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

branch_with_account = CROSS branch, account;
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Equi-join
\emph default
:
\family typewriter

\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

branch_and_account = JOIN branch BY sortcode
\end_layout

\begin_layout Plain Layout

                           account BY sortcode;
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Union
\emph default
:
\family typewriter

\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

id = UNION branch_sortcode, account_no;
\end_layout

\begin_layout Plain Layout

distinct_id = DISTINCT id;
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Difference
\emph default
: use a left join:
\family typewriter

\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

account_and_movement = JOIN account BY no LEFT,
\end_layout

\begin_layout Plain Layout

                            movement BY no;
\end_layout

\begin_layout Plain Layout

account_without_movement = 
\end_layout

\begin_layout Plain Layout

    FILTER account_and_movement
\end_layout

\begin_layout Plain Layout

    BY movement::no IS NULL;
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Group by
\emph default
: produces a 
\family typewriter
group
\family default
 column with the grouped-on value and a column containing a 
\emph on
bag
\emph default
 of tuples belonging to each group.
\family typewriter

\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

account_movements = GROUP movement BY no;
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Flatten
\emph default
: generate a row for each tuple in a bag:
\family typewriter

\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

movement_copy = FOREACH account_movements
\end_layout

\begin_layout Plain Layout

                GENERATE FLATTEN(movement);
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Aggregation
\emph default
: 
\family typewriter
COUNT(a)
\family default
, 
\family typewriter
COUNT_STAR(a)
\family default
, 
\family typewriter
AVG(a)
\family default
, 
\family typewriter
MAX(a)
\family default
, 
\family typewriter
MIN(a)
\family default
, 
\family typewriter
SUM(a)
\family default
, or 
\family typewriter
DIFF(a, b)
\family default
:
\family typewriter

\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

movement_copy =
\end_layout

\begin_layout Plain Layout

    FOREACH account_movements
\end_layout

\begin_layout Plain Layout

    GENERATE group AS no, 
\end_layout

\begin_layout Plain Layout

             SUM(movement.amount) AS balance;
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Cases
\emph default
: Use nested statements:
\family typewriter

\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

account_credit_and_debit =
\end_layout

\begin_layout Plain Layout

    FOREACH account_detail {
\end_layout

\begin_layout Plain Layout

        credit = FILTER account_and_movement
\end_layout

\begin_layout Plain Layout

                 BY amount > 0.0;
\end_layout

\begin_layout Plain Layout

        debit = FILTER account_and_movement
\end_layout

\begin_layout Plain Layout

                BY amount < 0.0;
\end_layout

\begin_layout Plain Layout

        GENERATE group AS no,
\end_layout

\begin_layout Plain Layout

                 COUNT(account_and_movement) AS ts,
\end_layout

\begin_layout Plain Layout

                 SUM(credit.amount) AS credit,
\end_layout

\begin_layout Plain Layout

                 SUM(debit.amount) AS debit;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Pig optimisations
\end_layout

\begin_layout Enumerate
Project before a 
\family typewriter
GROUP BY
\family default
: less data to handle in the 
\family typewriter
GROUP BY
\family default
.
\end_layout

\begin_layout Paragraph
Pig to MapReduce
\end_layout

\begin_layout Itemize

\family typewriter
FILTER
\family default
 and 
\family typewriter
FOREACH
\family default
 are implemented using Map.
\end_layout

\begin_layout Itemize

\family typewriter
GROUP
\family default
 implemented by a Combine, then Reduce.
\end_layout

\begin_layout Itemize
All others implemented as just a Reduce.
\end_layout

\begin_deeper
\begin_layout Itemize
If a Map process is after a Reduce, it can be put in the Reduce node.
\end_layout

\end_deeper
\begin_layout Paragraph
Distributed hash join
\end_layout

\begin_layout Enumerate
Each Map node generates its bit of each hash bucket.
\end_layout

\begin_layout Enumerate
Reduce gets all files belonging to a particular hash bucket and performs
 join.
\end_layout

\begin_layout Paragraph
Replicated join
\end_layout

\begin_layout Enumerate
Replicate the entire RHS (smaller table) to all Map nodes holding the LHS.
\end_layout

\begin_layout Enumerate
Execute join as a Map process.
\end_layout

\begin_layout Paragraph
Skewed join
\end_layout

\begin_layout Enumerate
Uses a histogram of the frequency of join keys.
\end_layout

\begin_layout Enumerate
Histogram used to distribute the join over Reduce nodes.
 For keys with high frequency in LHS:
\end_layout

\begin_deeper
\begin_layout Enumerate
Distribute rows from LHS using round-robin.
\end_layout

\begin_layout Enumerate
Duplicate rows from RHS to multiple Reduce nodes.
\end_layout

\end_deeper
\begin_layout Paragraph
Merge join
\end_layout

\begin_layout Standard
Assumes both inputs are sorted.
\end_layout

\begin_layout Enumerate
Map nodes of LHS load required blocks from RHS.
\end_layout

\begin_layout Enumerate
Execute sort-merge join as a Map process.
\end_layout

\begin_layout Section
Distributed query processing
\end_layout

\begin_layout Paragraph
DBMS componenets
\end_layout

\begin_layout Enumerate

\emph on
Transaction manager
\emph default
: query processor plans and translates queries.
\end_layout

\begin_layout Enumerate

\emph on
Scheduler
\emph default
: schedules primitive operators to obey ACID properties.
\end_layout

\begin_layout Enumerate

\emph on
Data manager
\emph default
: interacts with memory maintains durability of transactions.
\end_layout

\begin_layout Paragraph
Distribution of transaction processing
\end_layout

\begin_layout Standard
In a DDB:
\end_layout

\begin_layout Itemize
Each site runs a 
\emph on
Local Transaction Manager
\emph default
, scheduler and data manager.
\end_layout

\begin_layout Itemize
One or more sites run a 
\emph on
Global Transaction Manager
\emph default
.
\end_layout

\begin_deeper
\begin_layout Itemize
Transforms transaction into sub-transactions for each site.
\end_layout

\end_deeper
\begin_layout Subsubsection*
RA Equivalences
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Plain Layout

\family typewriter
SELECT
\family default
s over horizontal fragmentation:
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/select-horiz-frag.png
	width 80text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Plain Layout

\family typewriter
JOIN
\family default
s over derived horizontal fragmentation:
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/join-horiz-frag.png
	width 95text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Plain Layout
Always push 
\family typewriter
PROJECT
\family default
s inside 
\family typewriter
JOIN
\family default
:
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/project-in-join.png
	width 95text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Plain Layout
Always push 
\family typewriter
SELECT
\family default
s inside 
\family typewriter
JOIN
\family default
:
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/select-in-join.png
	width 95text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Plain Layout
Direct join (high selectivity) 
\begin_inset Formula $\rightleftarrows$
\end_inset

 semi join (low selectivity):
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/semi-join.png
	width 95text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Plain Layout
Local join 
\begin_inset Formula $\rightleftarrows$
\end_inset

 remote join (denormalises data):
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/remote-join.png
	width 95text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
SQL queries over fragmented data
\end_layout

\begin_layout Itemize

\emph on
Horizontal fragmentation
\emph default
: determined using 
\family typewriter
WHERE
\family default
 clause (
\begin_inset Formula $\sigma$
\end_inset

).
\end_layout

\begin_layout Itemize

\emph on
Vertical fragmentation
\emph default
: determined using 
\family typewriter
SELECT
\family default
 clause (
\begin_inset Formula $\pi$
\end_inset

), but must ensure 
\family typewriter
JOIN
\family default
 and 
\family typewriter
WHERE
\family default
 clauses can be processed.
\end_layout

\begin_layout Section
Concurrency control
\end_layout

\begin_layout Standard
DBMS implements indivisible tasks (
\emph on
transactions
\emph default
):
\end_layout

\begin_layout Enumerate

\emph on
Atomicity
\emph default
: all or nothing.
\end_layout

\begin_layout Enumerate

\emph on
Consistency
\emph default
: consistent before 
\begin_inset Formula $\rightarrow$
\end_inset

 consistent after.
\end_layout

\begin_layout Enumerate

\emph on
Isolation
\emph default
: indepenedent of any other transaction.
\end_layout

\begin_layout Enumerate

\emph on
Durability
\emph default
: completed transactions are durable.
\end_layout

\begin_layout Paragraph
Transaction histories
\end_layout

\begin_layout Standard
For a transaction 
\begin_inset Formula $T_{n}$
\end_inset

:
\end_layout

\begin_layout Enumerate
Begin transaction: 
\begin_inset Formula $b_{n}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Read / write operations on objects: 
\begin_inset Formula $r_{n}\left[o_{j}\right]$
\end_inset

 and 
\begin_inset Formula $w_{n}\left[o_{j}\right]$
\end_inset

.
\end_layout

\begin_layout Enumerate
Commit / abort: 
\begin_inset Formula $c_{n}$
\end_inset

 or 
\begin_inset Formula $a_{n}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Cocurrency control
\end_layout

\begin_layout Standard
Have to ensure:
\end_layout

\begin_layout Enumerate

\emph on
Serialisability
\emph default
: a concurrent execution of transactions should have the same end result
 as some serial execution.
\end_layout

\begin_layout Enumerate

\emph on
Recoverability
\emph default
: no transaction commits depending on data that has been produced by another
 transaction that has yet to commit.
\end_layout

\begin_layout Paragraph
Anomolies
\end_layout

\begin_layout Enumerate

\emph on
Lost update
\emph default
: 
\begin_inset Formula $T_{1}$
\end_inset

and 
\begin_inset Formula $T_{2}$
\end_inset

 update the same data element and one update is lost (overwritten).
\end_layout

\begin_layout Enumerate

\emph on
Inconsistent analysis
\emph default
: 
\begin_inset Formula $T_{1}$
\end_inset

 acesses data before 
\begin_inset Formula $T_{2}$
\end_inset

 finishes working with that data.
\end_layout

\begin_layout Enumerate

\emph on
Dirty read
\emph default
: 
\begin_inset Formula $T_{1}$
\end_inset

 reads a value that 
\begin_inset Formula $T_{2}$
\end_inset

 has written but not committed.
 Can cause non-recoverability.
\end_layout

\begin_layout Enumerate

\emph on
Dirty write
\emph default
: 
\begin_inset Formula $T_{1}$
\end_inset

 writes to an object that 
\begin_inset Formula $T_{2}$
\end_inset

 has written to but not committed.
 Makes recoverability hard.
\end_layout

\begin_layout Enumerate

\emph on
Phantom read
\emph default
: 
\begin_inset Formula $T_{1}$
\end_inset

 executes two queries, the second returning something different to the first,
 due 
\begin_inset Formula $T_{2}$
\end_inset

 inserting/removing an object.
\end_layout

\begin_layout Enumerate

\emph on
Write skew
\emph default
: 
\begin_inset Formula $T_{1}$
\end_inset

 and 
\begin_inset Formula $T_{2}$
\end_inset

 concurrently read overlapping data and then concurrently make updates.
\end_layout

\begin_layout Paragraph
Conflicts
\end_layout

\begin_layout Standard
An interaction between two transactions:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $r_{x}[o]$
\end_inset

 and 
\begin_inset Formula $w_{y}[o]$
\end_inset

 are in 
\begin_inset Formula $H$
\end_inset

, or
\end_layout

\begin_layout Enumerate
\begin_inset Formula $w_{x}[o]$
\end_inset

 and 
\begin_inset Formula $w_{y}[o]$
\end_inset

 are in 
\begin_inset Formula $H$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $H_{1}$
\end_inset

 and 
\begin_inset Formula $H_{2}$
\end_inset

 are conflict equivalent if:
\end_layout

\begin_layout Enumerate
They contain the same set of operations, and
\end_layout

\begin_layout Enumerate
Order conflicts (of non-aborted transactions) in the same way.
\end_layout

\begin_layout Standard
\begin_inset Formula $H$
\end_inset

 is conflict serialisable if 
\begin_inset Formula $C\left(H\right)\equiv_{CE}H'$
\end_inset

 where 
\begin_inset Formula $H'$
\end_inset

 is a serial history.
\end_layout

\begin_layout Paragraph
Serialisation graph
\end_layout

\begin_layout Standard
Contains a node for each transaction in 
\begin_inset Formula $H$
\end_inset

, and an edge if there as a conflict from one node to another.
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $SG\left(H\right)$
\end_inset

 is acyclic, then 
\begin_inset Formula $H$
\end_inset

 is conflict serialisable.
\end_layout

\begin_layout Paragraph
Recoverability
\end_layout

\begin_layout Standard
In addition to recoverability, we sometimes want to ensure:
\end_layout

\begin_layout Itemize

\emph on
Avoids cascading aborts
\emph default
: no dirty reads.
\end_layout

\begin_layout Itemize

\emph on
Strict execution
\emph default
: no dirty reads or writes.
\end_layout

\begin_layout Paragraph
Maintaining serialisability and recoverability
\end_layout

\begin_layout Enumerate

\emph on
Two-phase locking
\emph default
: conflict based.
\end_layout

\begin_layout Enumerate

\emph on
Time-stamping
\emph default
: add timestamps to object, only read or write objects with earlier timestamp.
\end_layout

\begin_layout Enumerate

\emph on
Optimistic concurrency control
\emph default
: inspect history for problems at commit.
\end_layout

\begin_layout Paragraph
2PL Protocol
\end_layout

\begin_layout Standard
Every history has a maximum lock period, we must be able to re-time history
 to make all operations take place during that period 
\begin_inset Formula $\implies$
\end_inset

 CSR.
\end_layout

\begin_layout Enumerate

\emph on
Read locks
\emph default
 (non-exclusive).
\end_layout

\begin_layout Enumerate

\emph on
Write locks
\emph default
 (exclusive).
\end_layout

\begin_layout Enumerate

\emph on
Growing
\emph default
 and 
\emph on
shrinking
\emph default
 phase: cannot gain a new lock after releasing a lock.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/2pl-anomolies.png
	width 95text%

\end_inset


\end_layout

\begin_layout Standard
2PL 
\emph on
does not prevent phantom reads / complex write skew
\emph default
s.
 Solutions:
\end_layout

\begin_layout Enumerate

\emph on
Table locks
\emph default
: read lock table when performing a scan:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $-$
\end_inset

 Can produce needless conflicts.
\end_layout

\begin_layout Itemize
\begin_inset Formula $+$
\end_inset

 Efficient if large parts of the table are being updated.
\end_layout

\end_deeper
\begin_layout Enumerate

\emph on
Predicate locking
\emph default
: lock the predicate that the transaction uses.
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $-$
\end_inset

 Difficult to implement.
\end_layout

\end_deeper
\begin_layout Standard
We can get 
\emph on
deadlocks
\emph default
 with 2PL: if WFG has a cycle.
\end_layout

\begin_layout Paragraph
Conservative locking
\end_layout

\begin_layout Standard
Obtain all locks at beginnning.
\end_layout

\begin_layout Itemize
\begin_inset Formula $+$
\end_inset

 Prevents deadlock.
\end_layout

\begin_layout Itemize
\begin_inset Formula $-$
\end_inset

 Quite difficult to tell what locks required.
\end_layout

\begin_layout Itemize
\begin_inset Formula $-$
\end_inset

 Not recoverable.
\end_layout

\begin_layout Paragraph
Strict locking
\end_layout

\begin_layout Standard
Prevent write locks being released before end of transaction.
\end_layout

\begin_layout Itemize
\begin_inset Formula $+$
\end_inset

 Prevents dirty reads/writes 
\begin_inset Formula $\implies$
\end_inset

 recoverability.
\end_layout

\begin_layout Itemize
\begin_inset Formula $-$
\end_inset

 Allows deadlock.
\end_layout

\begin_layout Paragraph
Strong strict locking
\end_layout

\begin_layout Standard
All locks released at end of transactions.
\end_layout

\begin_layout Itemize
\begin_inset Formula $+$
\end_inset

 Simple to implement.
\end_layout

\begin_layout Itemize
\begin_inset Formula $+$
\end_inset

 Suitable for distributed transactions.
\end_layout

\begin_layout Paragraph
SQL transaction isolation level
\end_layout

\begin_layout Standard

\family typewriter
SET TRANSACTION ISOLATION LEVEL ...
\end_layout

\begin_layout Enumerate

\family typewriter
READ UNCOMMITTED
\family default
 prevents only dirty writes.
\end_layout

\begin_layout Enumerate

\family typewriter
READ COMMITTED
\family default
 prevents dirty reads and writes.
\end_layout

\begin_layout Enumerate

\family typewriter
SNAPSHOT
\family default
 prevents all anomolies except write skew.
\end_layout

\begin_layout Enumerate

\family typewriter
REPEATABLE READ
\family default
 prevents all anomolies except phantom reads.
\end_layout

\begin_layout Enumerate

\family typewriter
SERIALIZABLE
\family default
 implements full serialisability.
\end_layout

\begin_layout Paragraph
Distributed concurrency control
\end_layout

\begin_layout Standard

\emph on
DWFG
\emph default
:
\end_layout

\begin_layout Enumerate
Add spawn double-edges to master.
\end_layout

\begin_layout Enumerate
When a local cycle appears, fetch remote WFG.
\end_layout

\begin_layout Standard

\emph on
Global 2PL
\emph default
: 2PL cannot just be executed at each site:
\end_layout

\begin_layout Enumerate
Use strong strict locking at each site, using a global atomic commit to
 end transaction.
\end_layout

\begin_layout Enumerate

\emph on
Two-phase commit
\emph default
:
\end_layout

\begin_deeper
\begin_layout Itemize
Can become blocked.
\end_layout

\end_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/2pc.png
	width 95text%

\end_inset


\end_layout

\begin_layout Standard

\emph on
Distributed locking
\emph default
: for 
\begin_inset Formula $n$
\end_inset

 sites, 
\end_layout

\begin_layout Itemize

\emph on
Write-write conflicts
\emph default
: at least 
\begin_inset Formula $\left\lceil \frac{n+1}{2}\right\rceil $
\end_inset

 sites must be sent write lock.
\end_layout

\begin_layout Itemize

\emph on
Read-write conflicts
\emph default
: at least 
\begin_inset Formula $n-k+1$
\end_inset

 sites must be sent a read lock, where 
\begin_inset Formula $k$
\end_inset

 is the number of write locks.
\end_layout

\begin_layout Section
Temporal databses
\end_layout

\begin_layout Paragraph
Temporal dimenstions
\end_layout

\begin_layout Enumerate

\emph on
Valid time
\emph default
: time data valid in Universe of Discourse.
\end_layout

\begin_layout Enumerate

\emph on
Transaction time
\emph default
: time data valid in DBMS.
\end_layout

\begin_layout Paragraph
Modelling a flow of time
\end_layout

\begin_layout Enumerate

\emph on
Discrete
\emph default
 vs 
\emph on
continuous
\emph default
.
\end_layout

\begin_layout Enumerate

\emph on
Unbounded
\emph default
 vs 
\emph on
bounded
\emph default
.
\end_layout

\begin_layout Enumerate

\emph on
Linear
\emph default
 vs 
\emph on
branching
\emph default
.
\end_layout

\begin_layout Paragraph
US-Logic
\end_layout

\begin_layout Enumerate

\emph on
\begin_inset Formula $A$
\end_inset

 until 
\begin_inset Formula $B$
\end_inset

:
\emph default
 
\begin_inset Formula $A$
\end_inset

 holds at every time up to an including the time when 
\begin_inset Formula $B$
\end_inset

 holds.
\end_layout

\begin_layout Enumerate

\emph on
\begin_inset Formula $A$
\end_inset

 since 
\begin_inset Formula $B$
\end_inset


\emph default
: 
\begin_inset Formula $A$
\end_inset

 has held at every time since and including the time when 
\begin_inset Formula $B$
\end_inset

 held.
\end_layout

\begin_layout Enumerate

\emph on
\begin_inset Formula $A$
\end_inset

 since product 
\begin_inset Formula $B$
\end_inset


\emph default
: 
\begin_inset Formula $\text{eval}\left(A\overset{S}{\times}B,t\right)=\text{eval}\left(\left(A\times B\right)\cup\left(\left(A\overset{S}{\times}B\right)\ltimes A\right),t-1\right)$
\end_inset

.
\end_layout

\begin_layout Enumerate

\emph on
\begin_inset Formula $A$
\end_inset

 until product 
\begin_inset Formula $B$
\end_inset


\emph default
: 
\begin_inset Formula $\text{eval}\left(A\overset{U}{\times}B,t\right)=\text{eval}\left(\left(A\times B\right)\cup\left(\left(A\overset{U}{\times}B\right)\ltimes A\right),t+1\right)$
\end_inset

.
\end_layout

\begin_layout Standard
We can derive:
\end_layout

\begin_layout Enumerate

\emph on
\begin_inset Formula $A$
\end_inset

 since join 
\begin_inset Formula $B$
\end_inset


\emph default
: 
\begin_inset Formula $\text{eval}\left(A\overset{S}{\bowtie}B,t\right)=\text{eval}\left(\sigma_{A.x=B.x}\left(A\overset{S}{\times}B\right),t\right)$
\end_inset

.
\end_layout

\begin_layout Enumerate

\emph on
\begin_inset Formula $A$
\end_inset

 until join 
\begin_inset Formula $B$
\end_inset


\emph default
: 
\begin_inset Formula $\text{eval}\left(A\overset{U}{\bowtie}B,t\right)=\text{eval}\left(\sigma_{A.x=B.x}\left(A\overset{U}{\times}B\right),t\right)$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\Circle A\equiv A\text{ Until }\top$
\end_inset

: 
\begin_inset Formula $A$
\end_inset

 is true at the next time.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\CIRCLE A\equiv A\text{ Since }\top$
\end_inset

: 
\begin_inset Formula $A$
\end_inset

 is true at the previous time.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\lozenge A\equiv\top\text{ Until }A$
\end_inset

: 
\begin_inset Formula $A$
\end_inset

 is true at some time in the future.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\blacklozenge A\equiv\top\text{ Since }B$
\end_inset

: 
\begin_inset Formula $A$
\end_inset

 is true at some time in the past.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\square A\equiv A\text{ Until }\lnot\Circle\top$
\end_inset

: 
\begin_inset Formula $A$
\end_inset

 is always true in the future.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\blacksquare A\equiv A\text{ Since }\lnot\CIRCLE\top$
\end_inset

: 
\begin_inset Formula $A$
\end_inset

 is always true in the past.
\end_layout

\end_body
\end_document
